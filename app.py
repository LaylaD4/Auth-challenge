from flask import Flask, jsonify, request, abort
from marshmallow.validate import Length

app = Flask(__name__)

from flask_marshmallow import Marshmallow
ma = Marshmallow(app)

# For hash 
from flask_bcrypt import Bcrypt
bcrypt = Bcrypt(app)

from datetime import date, timedelta

app.config["JWT_SECRET_KEY"] = "Backend best end"
from flask_jwt_extended import JWTManager, create_access_token, jwt_required, get_jwt_identity
jwt = JWTManager(app)

## DB CONNECTION AREA

from flask_sqlalchemy import SQLAlchemy 
app.config["SQLALCHEMY_DATABASE_URI"] = "postgresql+psycopg2://tomato:123456@localhost:5432/ripe_tomatoes_db"
app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False

db = SQLAlchemy(app)

# CLI COMMANDS AREA

@app.cli.command("create")
def create_db():
    db.create_all()
    print("Tables created")

@app.cli.command("seed")
def seed_db():

    movie1 = Movie(
        title = "Spider-Man: No Way Home",
        genre = "Action",
        length = 148,
        year = 2021
    )
    db.session.add(movie1)

    movie2 = Movie(
        title = "Dune",
        genre = "Sci-fi",
        length = 155,
        year = 2021
    )
    db.session.add(movie2)

    actor1 = Actor(
        first_name = "Tom",
        last_name = "Holland",
        gender = "male",
        country = "UK"
    )
    db.session.add(actor1)

    actor2 = Actor(
        first_name = "Marisa",
        last_name = "Tomei",
        gender = "female",
        country = "USA"
    )
    db.session.add(actor2)

    actor3 = Actor(
        first_name = "Timothee",
        last_name = "Chalemet",
        gender = "male",
        country = "USA"
    )
    db.session.add(actor3)

    actor4 = Actor(
        first_name = "Zendaya",
        last_name = "",
        gender = "female",
        country = "USA"
    )
    db.session.add(actor4)

    # Seed the database with one new user. (Note: passwords need to be stored in db with a hash generated by bcrypt)
    user1 = User(
        user_name = "LaylaD4",
        password = bcrypt.generate_password_hash("12345678").decode("utf-8"),
        admin = True
    )
    db.session.add(user1)

    db.session.commit()
    print("Tables seeded") 


@app.cli.command("drop")
def drop_db():
    db.drop_all()
    print("Tables dropped") 

# MODELS AREA

class Movie(db.Model):
    __tablename__= "movies"
    id = db.Column(db.Integer,primary_key=True)
    title = db.Column(db.String())
    genre = db.Column(db.String())
    length = db.Column(db.Integer())
    year = db.Column(db.Integer())

class Actor(db.Model):
    __tablename__= "actors"
    id = db.Column(db.Integer,primary_key=True)  
    first_name = db.Column(db.String())
    last_name = db.Column(db.String())
    gender = db.Column(db.String())
    country = db.Column(db.String())

# Create the user model (username and password).
class User(db.Model):
    __tablename__="users"
    id = db.Column(db.Integer, primary_key=True)
    user_name = db.Column(db.String(), nullable=False, unique=True)
    password = db.Column(db.String(), nullable=False) 
    admin = db.Column(db.Boolean(), default=False)   

# SCHEMAS AREA

class MovieSchema(ma.Schema):
    class Meta:
        fields = ("id", "title", "genre", "length", "year")

movie_schema = MovieSchema()
movies_schema = MovieSchema(many=True)

class ActorSchema(ma.Schema):
    class Meta:
        fields = ("id", "first_name", "last_name", "gender", "country")

actor_schema = ActorSchema()
actors_schema = ActorSchema(many=True)

# Create the user schema (password length at least 8 characters)
class UserSchema(ma.SQLAlchemyAutoSchema):
    class Meta:
        model = User
    # Set the password length to a minimum of 8 characters.
    password = ma.String(validate=Length(min=8))

user_schema = UserSchema()
users_schema = UserSchema(many=True)


# ROUTING AREA

@app.route("/")
def hello():
  return "Welcome to Ripe Tomatoes API"

@app.route("/movies", methods=["GET"])
def get_movies():
    stmt = db.select(Movie)
    movies = db.session.scalars(stmt)
    return movies_schema.dump(movies)

@app.route("/movies", methods=["POST"])
@jwt_required()
def add_movie():
    # Create a new movie
    movie_fields = movie_schema.load(request.json)
    new_movie = Movie()
    new_movie.title = movie_fields["title"]
    new_movie.genre = movie_fields["genre"]
    new_movie.length = movie_fields["length"]
    new_movie.year = movie_fields["year"]
    # Add to the database and commit
    db.session.add(new_movie)
    db.session.commit()
    # return the movie in response
    return jsonify(movie_schema.dump(new_movie))

@app.route("/movies/<int:id>", methods=["DELETE"])
@jwt_required()
def delete_movie(id):
    # First step is to authenticate that the user is part of the admin.
    # Get the user id invoking get_jwt_identity
    user_id = get_jwt_identity()
    # Find it in the database
    stmt = db.select(User).filter_by(id=user_id)
    user = db.session.scalar(stmt)
    # Make sure user is in the database
    if not user:
        return abort(401, description="Invalid user")
    # Stop the request if the user is not an admin user
    if not user.admin:
        return abort(401, description="Unauthorised user")
    # Find the movie
    stmt = db.select(Movie).filter_by(id=id)
    movie = db.session.scalar(stmt)
    # Return an error if movie does not exist.
    if not movie:
        return abort(400, description="Movie does not exist")
    # Delete the movie from the database and commit the changes
    db.session.delete(movie)
    db.session.commit()
    # Return the movie in response
    return jsonify(movie_schema.dump(movie))

    
@app.route("/actors", methods=["GET"])
def get_actors():
    stmt = db.select(Actor)
    actors = db.session.scalars(stmt)
    return actors_schema.dump(actors)

@app.route("/actors/<int:id>", methods=["DELETE"])
@jwt_required()
def delete_actor(id):
    # Find and validate user
    user_id = get_jwt_identity()
    stmt = db.select(User).filter_by(id=user_id)
    user = db.session.scalar(stmt)
    if not user:
        return abort(401, description="Invalid user")
    if not user.admin:
        return abort(401, description="Unauthorised user")
    # Find and delete actor
    stmt = db.select(Actor).filter_by(id=id)
    actor = db.session.scalar(stmt)
    if not actor:
        return abort(400, description="Actor does not exist")
    db.session.delete(actor)
    db.session.commit()
    # Return card in the response
    return jsonify(actor_schema.dump(actor))
    

@app.route("/actors", methods=["POST"])
@jwt_required()
def add_actor():
    actor_fields = actor_schema.load(request.json)
    new_actor = Actor()
    new_actor.first_name = actor_fields["first_name"]
    new_actor.last_name = actor_fields["last_name"]
    new_actor.gender = actor_fields["gender"]
    new_actor.country = actor_fields["country"]

    db.session.add(new_actor)
    db.session.commit()

    return jsonify(actor_schema.dump(new_actor))

# Create the /auth/signup route:
@app.route("/auth/signup", methods=["POST"])
def auth_signup():
    user_fields = user_schema.load(request.json)
    # Look for user_name entered.
    stmt = db.select(User).filter_by(user_name=request.json['user_name'])
    user = db.session.scalar(stmt)
    # Check if the user_name already exists.
    if user:
        return abort(400, description="User name already exists")
    # Create user object.
    user = User()
    # Add user_name attribute.
    user.user_name = user_fields["user_name"]
    # Add password attribute hashed by bcrypt
    user.password = bcrypt.generate_password_hash(user_fields["password"]).decode("utf-8")

    # Add the new user to the database and commit the changes.
    db.session.add(user)
    db.session.commit()

    # Variable to set an expiry date for token:
    expiry = timedelta(days=1)
    # Creating jwt access token.
    access_token = create_access_token(identity=str(user.id), expires_delta=expiry)
    # Return the user's user_name and the access token
    return jsonify({"user":user.user_name, "token":access_token})

# Create the /auth/signin route:
@app.route("/auth/signin", methods=["POST"])
def auth_signin():
    user_fields = user_schema.load(request.json)
    # Find the user by user_name.
    stmt = db.select(User).filter_by(user_name=request.json['user_name'])
    user = db.session.scalar(stmt)
    # If there is no user with the user_name or password send message.
    if not user or not bcrypt.check_password_hash(user.password, user_fields["password"]):
        return abort(401, description="Incorrect username and password")
    # Variable that holds expiry date to be applied to token
    expiry = timedelta(days=1)
    # Create access token, and store in variable.
    access_token = create_access_token(identity=str(user.id), expires_delta=expiry)
    # Return the user's user_name and access token
    return jsonify({"user": user.user_name, "token": access_token})


